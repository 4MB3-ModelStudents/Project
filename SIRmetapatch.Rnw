\documentclass{article}
\input 4mbapreamble

\begin{document}

<<detSIRmeta,dev="tikz">>=
library("deSolve")

## Vector Field for SIR Metapatch Model
SIRmeta.vector.field <- function(t,vars,parms=NULL) {
  ##parms should be of form (R_0,gamma,mu,alpha,m,EC)
  ##vars should be of form (S,I,R)
  with(as.list(c(parms,vars)), {
    n <- length(vars)/3
    S <- vars[1:n]
    I <- vars[(n+1):(2*n)]
    R <- vars[(2*n+1):(3*n)]
    
    #Equal Coupling
    if(EC==TRUE){
      M <- matrix(m,n,n)+(1-m)*diag(n)   ##connectivity matrix
      betam <- R_0*(gamma+mu)*(1+alpha*cos(2*pi*t/365))*(1/(1+(n-1)*m))*M  ##beta matrix
    }else{
      #Nearest Neighbors
      M <- diag(n)
      M[row(M)%%n==(col(M)+1)%%n ] <- m
      M[row(M)%%n==(col(M)-1)%%n] <- m
      betam <- R_0*(gamma+mu)*(1+alpha*cos(2*pi*t/365))*M  ##beta matrix
    }
    
    dS <- NULL
    dI <- NULL
    dR <- NULL
    for (i in 1:n){
      dS[i] <- mu*(1-S[i]) - S[i]*sum(betam[i,]*I) ##dS_i/dt
      dI[i] <- S[i]*sum(betam[i,]*I) - (mu+gamma)*I[i]  ## dI_i/dt
      dR[i] <- gamma*I[i] -mu*R[i]
    }
    vec.fld <- c(dS=dS,dI=dI,dR=dR)
    return(list(vec.fld))
  })
}

## Draw Solutions and coherence measure
draw.soln <- function(n,ic=c(x=rep(1,10),y=rep(0,10)),tmax=1,
                      times=seq(0,tmax,
                                by=tmax/1000),
                      func,parms,...) {
  soln <- ode(ic,times,func,parms)
  
  #Plot I for all patches with different colours
  for (i in 1:n){
    lines(times,soln[,paste0('I',i)],col=i,...)
  }
  
  #Measure of coherence
  coherence <- lapply(1:length(times), function(tims) sqrt(sum((soln[tims,paste0('I',1:n)]-mean(soln[tims,paste0('I',1:n)])*rep(1,n))^2)) )
  
  lines(times,coherence,lwd=2,...)
  
  #subscripts not working
  legend("topright",legend=lapply(1:n, function(i) bquote(I[.(i)])),col=1:n,lty=1)
  text(x=8000,y=0.0003, labels="$\\| I - \\langle I \\rangle  e \\|$")
}

#Parameters
R_0 <- 17   ##basic reproduction rate (if the system had no forcing)
gamma <- 1/13  ##inverse of mean infectious period
mu <- 1/(50*365)  ##death and birth rate
alpha <- 0.1  ##strength of seasonal forcing
n <- 10  ## Number of patches
m <- 0.2  ##Connectivity matrix parameter
EC <- FALSE ##if true use equal coupling, if false use nearest neighbors

##Initial conditions
#S0 <- seq(0.3,0.7,(0.7-0.3)/(n-1))
S0 <- seq(0.04,0.1, (0.1-0.04)/(n-1))
I0 <- rep(1e-4,n)
R0 <- 1-S0-I0

tmax<-10000

## draw box for plot
plot(0,0,xlim=c(0,tmax),ylim=c(0,0.006),type="n",xlab="Time (t)",
     ylab="Prevalence (I)",las=1)

## draw solutions
draw.soln(n,ic=c(S=S0,I=I0,R=R0),tmax=tmax,
            func=SIRmeta.vector.field,
            parms=c(R_0,gamma,mu,alpha,m,EC))


@

<<coherencemap,dev="tikz">>=
##This code is NOT finished!!
solncoherence <- function(n,ic=c(x=rep(1,10),y=rep(0,10)),tmax=1,
                      times=seq(0,tmax,
                                by=tmax/800),
                      func,parms){
  soln <- ode(ic,times,func,parms)
  coherence <- lapply(1:length(times), function(tims) sqrt(sum((soln[tims,paste0('I',1:n)]-mean(soln[tims,paste0('I',1:n)])*rep(1,n))^2)) )
  return(coherence)
}

#Parameters
gamma <- 4/365  ##inverse of mean infectious period
mu <- 1/50  ##death and birth rate
alpha <- 0.1  ##strength of seasonal forcing
n <- 10  ## Number of patches
EC <- FALSE ##if true use equal coupling, if false use nearest neighbors
R_0 <- seq(0,5,0.5)
m <- seq(0,1,0.1)

##Initial conditions
S0 <- seq(0.5,1,(1-0.5)/(n-1))
I0 <- 1-S0
R0 <- rep(0,n)

tmax <- 3000

coherencem <- matrix(0,length(R_0),length(m))
for (i in 1:length(R_0)){
  for (j in 1:length(m)){
    #Coherence at time step 40
    coherencem[i,j] <- as.numeric(solncoherence(n,ic=c(S=S0,I=I0,R=R0),tmax=tmax,
            func=SIRmeta.vector.field,
            parms=c(R_0=R_0[i],gamma,mu,alpha,m=m[j],EC))[400])
  }
}

heatmap(coherencem, xlab="\\R_0", ylab="m")

## draw box for plot
#plot(0,0,xlim=c(0,20),ylim=c(0,1),type="n",xlab="Basic Reproduction Rate ($\\R_0$)",
#     ylab="Dispersal Parameter (m)",las=1)

@


<<SIRmeta.Gillespie>>=
SIRmeta.Gillespie <- function(tmax,ic=c(S0,I0,R0),parms=c(R_0=2,gamma=0.25,mu=4e-5,alpha=0.1,m=0.2,EC=TRUE)){
  times <- 0
  
  n <- length(ic)/3
  S <- matrix(0,1,n)
  I <- matrix(0,1,n)
  R <- matrix(0,1,n)
  S[1,] <- ic[1:n]
  I[1,] <- ic[(n+1):(2*n)]
  R[1,] <- ic[(2*n+1):(3*n)]
  
  index <- 1
  while(times[index] < tmax){
    #A matrix of all rates
    rates <- matrix(0,n,6)
    #the first column is all birth rates
    rates[,1] <- mu*(S[index,]+I[index,]+R[index,])
    #thrid column are recovery rates
    rates[,3] <- gamma*I[index,]
    #last three columns are death rates from S and I
    rates[,4] <- mu*S[index,]
    rates[,5] <- mu*I[index,]
    rates[,6] <- mu*R[index,]
    #second column are rates from S to I
    #Equal Coupling
    if(EC==TRUE){
      M <- matrix(m,n,n)+(1-m)*diag(n)   ##connectivity matrix
      betam <- R_0*(gamma+mu)*(1+alpha*cos(2*pi*times[index]/365))*(1/(1+(n-1)*m))*M  ##beta matrix 
    }else{
      #Nearest Neighbors
      M <- diag(n)
      M[row(M)%%n==(col(M)+1)%%n ] <- m
      M[row(M)%%n==(col(M)-1)%%n] <- m
      betam <- R_0*(gamma+mu)*(1+alpha*cos(2*pi*times[index]/365))*(1/(1+2*m))*M  ##beta matrix 
    }
    rates[,2] <- S[index,]*colSums(t(betam[1:n,])*I[index,])
     totalrate <- sum(rates)
    
    #Getting a timestep
    timestep <- rexp(n=1, rate= totalrate)
    times <- rbind(times, times[index]+timestep)
    
    S <- rbind(S, S[index,])
    I <- rbind(I, I[index,])
    R <- rbind(R, R[index,])
    
    #Getting which transistion occurred
    #TO DO!!: Do a bisection search instead
    randomvar <- runif(n=1,min=0,max=totalrate)
    indCheck <- 1
    rateslisted <- c(0,as.vector(t(rates)))
    while(indCheck < (6*n)){
      if(randomvar >= sum(rateslisted[1:indCheck]) & randomvar < sum(rateslisted[1:(indCheck+1)])){
        interval <- indCheck
        break
      }else{
        indCheck<- indCheck+1
      }
    }
    colInd <- interval%%6
    rowInd <- ceiling(interval/6)
    if(colInd ==1){  ##A birth occurred
      S[index+1,rowInd] <- S[index,rowInd]+1
    }else if(colInd ==2){  ##An infection occurred
      S[index+1,rowInd] <- S[index,rowInd]-1
      I[index+1,rowInd] <- I[index,rowInd]+1
    }else if(colInd ==3){  ##A recovery occurred
      I[index+1,rowInd] <- I[index,rowInd]-1
      R[index+1,rowInd] <- R[index,rowInd]+1
    }else if(colInd ==4){  ##A death in S occurred
      S[index+1,rowInd] <- S[index,rowInd]-1
    }else if(colInd ==5){  ##A death in I occurred
      I[index+1,rowInd] <- I[index,rowInd]-1
    }else if(colInd ==0){  ##A death in R occurred
      R[index+1,rowInd] <-  R[index,rowInd]-1
    }
    index <- index+1
  }
  return(cbind(times, S,I, R))
}
tmax <- 1
n <- 10
##Initial conditions
S0 <- seq(1,100,10)
I0 <- 100-S0
R0 <- rep(0,n)
#Parameters
R_0 <- 2   ##basic reproduction rate (if the system had no forcing)
gamma <- 4/365  ##inverse of mean infectious period
mu <- 1/50  ##death and birth rate
alpha <- 0.1  ##strength of seasonal forcing
n <- 10  ## Number of patches
m <- 0.1  ##Connectivity matrix parameter
EC <- FALSE ##if true use equal coupling, if false use nearest neighbors
set.seed(789)
results <- SIRmeta.Gillespie(tmax,ic=c(S0,I0,R0),parms=c(R_0,gamma,mu,alpha,m,EC))
times<-results[,1]
I <- results[,(n+1):(2*n+1)]
plot(times,I)
@

\end{document}